<?php
/**
 * The Select Query builder class.
 *
 * This class is used to build MySQL queries for the custom tables.
 * This is a helper class which generates complex SQL SELECT queries
 * by accepting simple arguments.
 *
 * @author     Joel James <me@joelsays.com>
 * @license    http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * @copyright  Copyright (c) 2020, Joel James
 * @link       https://github.com/DuckDev/wp-query-builder/
 * @package    Query
 * @since      1.0.0
 * @subpackage Select
 */

namespace DuckDev\Queries;

// If this file is called directly, abort.
defined( 'WPINC' ) || die;

/**
 * Class Query
 *
 * @package DuckDev\Redirect\Models
 */
class Select {

	/**
	 * Current table name to query for.
	 *
	 * @var string $table
	 *
	 * @since 4.0
	 */
	private $table;

	/**
	 * Fields to select from the table.
	 *
	 * @var string|array $select Select fields.
	 *
	 * @since 4.0
	 */
	private $select = '*';

	/**
	 * Where conditions for the query.
	 *
	 * @var array $where
	 *
	 * @since 4.0
	 */
	private $where = array();

	/**
	 * Where conditions for OR statements.
	 *
	 * @var array $or_where
	 *
	 * @since 4.0
	 */
	private $or_where = array();

	/**
	 * Join statements for the query.
	 *
	 * @var array $join
	 *
	 * @since 4.0
	 */
	private $join = array();

	/**
	 * Group by field name.
	 *
	 * @var string $group_by
	 *
	 * @since 4.0
	 */
	private $group_by = '';

	/**
	 * Order field name to order the results.
	 *
	 * @var string $order
	 *
	 * @since 4.0
	 */
	private $order = 'DESC';

	/**
	 * Order for the results (ASC/DESC).
	 *
	 * @var string $order_by
	 *
	 * @since 4.0
	 */
	private $order_by = 'id';

	/**
	 * Final query generated by the builder.
	 *
	 * @var string $query
	 *
	 * @since 4.0
	 */
	private $query = '';

	/**
	 * Set table to run the select query on.
	 *
	 * @param string $table Table name (without prefix).
	 *
	 * @since 4.0
	 *
	 * @return Select $this
	 */
	public function table( $table ) {
		// Set table.
		$this->table = $table;

		return $this;
	}

	/**
	 * Fields to select from the DB.
	 *
	 * This can be set once. If you call this multiple
	 * times, this will replace existing select fields.
	 *
	 * @param string|array $fields A single field name or array of field names.
	 *
	 * @since 4.0
	 *
	 * @return Select $this
	 */
	public function select( $fields = array() ) {
		if ( empty( $fields ) ) {
			// Select all fields if nothing specified.
			$this->select = '*';
		} else {
			$this->select = $fields;
		}

		return $this;
	}

	/**
	 * Set where conditions for the query.
	 *
	 * By default AND relation is used for the multiple
	 * where statements. To add an OR relation, please
	 * use or_where() method.
	 *
	 * @param string     $field    Field name.
	 * @param string|int $value    Field value.
	 * @param string     $operator Where operator.
	 *
	 * @since 4.0
	 *
	 * @return Select $this
	 */
	public function where( $field, $value, $operator = '=' ) {
		// Add to the conditions.
		$this->where[] = array(
			'field'    => $field,
			'value'    => $value,
			'operator' => $operator,
		);

		return $this;
	}

	/**
	 * Where condition which used OR relation.
	 *
	 * Multiple conditions can be set using array.
	 * If an array of condition is passed, we will
	 * group then with an AND relation and then add it
	 * to the original WHERE statement with OR relation.
	 *
	 * @param string|array $field    Field name.
	 * @param string|int   $value    Field value.
	 * @param string       $operator Where operator.
	 *
	 * @since 4.0
	 *
	 * @return Select $this
	 */
	public function or_where( $field, $value = '', $operator = '=' ) {
		if ( is_array( $field ) ) {
			// Mark it as a group.
			$group = array( 'group' => true );
			foreach ( $field as $where ) {
				// Set each conditions from the group.
				if ( isset( $where['field'], $where['value'] ) ) {
					$group['conditions'][] = array(
						'field'    => $where['field'],
						'value'    => $where['value'],
						'operator' => isset( $where['operator'] ) ? $where['operator'] : '=',
					);
				}
			}
			// Add group to the list.
			$this->or_where[] = $group;
		} else {
			// Add condition to the list.
			$this->or_where[] = array(
				'field'    => $field,
				'value'    => $value,
				'operator' => $operator,
			);
		}

		return $this;
	}

	/**
	 * Join with another table for querying.
	 *
	 * This will create a JOIN statement.
	 *
	 * @param string $table    Table name to join.
	 * @param string $field1   First table field name.
	 * @param string $field2   Second table field name.
	 * @param string $operator Join operator.
	 *
	 * @since 4.0
	 *
	 * @return Select $this
	 */
	public function join( $table, $field1, $field2, $operator = '=' ) {
		// Setup join list.
		$this->join[] = array(
			'table'    => $table,
			'field1'   => $field1,
			'field2'   => $field2,
			'operator' => $operator,
		);

		return $this;
	}

	/**
	 * Add a GROUP BY statement for the query.
	 *
	 * @param string $field Field name to group by.
	 *
	 * @since 4.0
	 *
	 * @return Select $this
	 */
	public function group_by( $field ) {
		// Set group by.
		$this->group_by = $field;

		return $this;
	}

	/**
	 * Setup the result order using ORDER BY statement.
	 *
	 * @param string $field Field to order by.
	 * @param string $order Order (ASC/DESC).
	 *
	 * @since 4.0
	 *
	 * @return Select $this
	 */
	public function order_by( $field, $order = 'DESC' ) {
		// Set order.
		$this->order = strtoupper( $order ) === 'ASC' ? 'ASC' : 'DESC';
		// Set order by field.
		$this->order_by = $field;

		return $this;
	}

	/**
	 * Get the final query string.
	 *
	 * Generate the query if it was not already
	 * generated by the builder.
	 * Make sure to setup all conditions before
	 * calling this method.
	 *
	 * @since 4.0
	 *
	 * @return string
	 */
	public function query() {
		// If not built, build query now.
		if ( empty( $this->query ) ) {
			$this->build_query();
		}

		/**
		 * Filter to modify final query before returning.
		 *
		 * @param string $query Query.
		 * @param Select $this  Query class instance.
		 *
		 * @since 4.0
		 */
		return apply_filters( '404_to_301_model_query_final', $this->query, $this );
	}

	/**
	 * Retrieves one variable from the database.
	 *
	 * Executes a SQL query and returns the value from the SQL result.
	 * If the SQL result contains more than one column and/or more than one row,
	 * the value in the column and row specified is returned. If $query is null,
	 * the value in the specified column and row from the previous SQL result is returned.
	 *
	 * @since 4.0
	 *
	 * @uses  WPDB::get_var()
	 *
	 * @return string|null Database query result (as string), or null on failure.
	 */
	public function get_var() {
		// If query is empty, don't do it.
		if ( empty( $this->query() ) ) {
			return null;
		}

		global $wpdb;

		// No need to show errors. It's our query.
		$wpdb->hide_errors();

		// phpcs:ignore
		$result = $wpdb->get_var( $this->query() );

		// Show errors after running our query.
		$wpdb->show_errors();

		return $result;
	}

	/**
	 * Retrieves one row from the database.
	 *
	 * Executes a SQL query and returns the row from the SQL result.
	 *
	 * @since 4.0
	 *
	 * @uses  WPDB::get_row()
	 *
	 * @return array|object|null|void Database query result in format specified by $output or null on failure.
	 */
	public function get_row() {
		// If query is empty, don't do it.
		if ( empty( $this->query() ) ) {
			return null;
		}

		global $wpdb;

		// No need to show errors. It's our query.
		$wpdb->hide_errors();

		// phpcs:ignore
		$results = $wpdb->get_row( $this->query() );

		// Show errors after running our query.
		$wpdb->show_errors();

		return $results;
	}

	/**
	 * Retrieves an entire SQL result set from the database (i.e., many rows).
	 *
	 * Executes a SQL query and returns the entire SQL result.
	 *
	 * @param string $output Optional. Any of ARRAY_A | ARRAY_N | OBJECT | OBJECT_K constants.
	 *                       With one of the first three, return an array of rows indexed
	 *                       from 0 by SQL result row number. Each row is an associative array
	 *                       (column => value, ...), a numerically indexed array (0 => value, ...),
	 *                       or an object ( ->column = value ), respectively. With OBJECT_K,
	 *                       return an associative array of row objects keyed by the value
	 *                       of each row's first column's value. Duplicate keys are discarded.
	 *
	 * @since 4.0
	 *
	 * @uses  WPDB::get_results()
	 *
	 * @return array|object|null Database query results.
	 */
	public function results( $output = OBJECT ) {
		// If query is empty, don't do it.
		if ( empty( $this->query() ) ) {
			return null;
		}

		global $wpdb;

		// No need to show errors. It's our query.
		$wpdb->hide_errors();

		// phpcs:ignore
		$results = $wpdb->get_results( $this->query(), $output );

		// Show errors after running our query.
		$wpdb->show_errors();

		return $results;
	}

	/**
	 * Reset the query class to default.
	 *
	 * We will remove the built query, all
	 * query conditions set.
	 *
	 * @since 4.0
	 *
	 * @return void
	 */
	public function reset() {
		// Rest all values to default.
		$this->query    = '';
		$this->select   = '*';
		$this->where    = array();
		$this->or_where = array();
		$this->group_by = array();
		$this->order_by = 'id';
		$this->order    = 'DESC';
	}

	/**
	 * Build SQL SELECT query based on the conditions.
	 *
	 * Process all the conditions set, and create a proper
	 * SQL SELECT query.
	 *
	 * @since  4.0
	 * @access private
	 *
	 * @return void
	 */
	private function build_query() {
		// Get select items.
		$select = $this->get_select();

		// Base query part.
		$sql = "SELECT $select FROM `$this->table`";

		// Setup all conditions.
		$sql = $this->set_join( $sql );
		$sql = $this->set_where( $sql );
		$sql = $this->set_order( $sql );
		$sql = $this->set_group( $sql );

		// Set final query.
		$this->query = $sql;
	}

	/**
	 * Setup SELECT fields for the query.
	 *
	 * If no field is set, we will select * from
	 * the table.
	 * Multiple fields can be selected using a comma
	 * separated array.
	 *
	 * @since 4.0
	 *
	 * @return string
	 */
	private function get_select() {
		if ( empty( $this->select ) ) {
			// Select all if not specified.
			$sql = '*';
		} elseif ( is_array( $this->select ) ) {
			// Select multiple fields.
			$sql = implode( ',', $this->select );
		} else {
			// Select single field.
			$sql = $this->select;
		}

		return $sql;
	}

	/**
	 * Setup WHERE condition statement.
	 *
	 * This is the most complex part of query building.
	 * Setup multiple WHERE conditions using AND relation.
	 * Setup group conditions when provided as an array.
	 * Setup OR relations for the conditions set in or_where
	 * property.
	 *
	 * @param string $sql SQL query which is being built.
	 *
	 * @return string Query
	 */
	private function set_where( $sql ) {
		// No need to do anything if no conditions set.
		if ( empty( $this->where ) && empty( $this->or_where ) ) {
			return $sql;
		}

		$query     = '';
		$wheres    = array();
		$or_wheres = array();

		// Process all AND relations.
		foreach ( $this->where as $where ) {
			if ( is_null( $where['value'] ) ) {
				$wheres[] = "`{$where['field']}` IS NULL";
			} else {
				$wheres[] = "`{$where['field']}` {$where['operator']} '{$where['value']}'";
			}
		}

		// Use only if not empty.
		if ( ! empty( $wheres ) ) {
			$query = implode( ' AND ', $wheres );
		}

		// Process all OR relations.
		foreach ( $this->or_where as $where ) {
			// If a group, group conditions using ().
			if ( isset( $where['group'], $where['conditions'] ) ) {
				$or_wheres_group = array();
				foreach ( $where['conditions'] as $condition ) {
					if ( is_null( $condition['value'] ) ) {
						$or_wheres_group[] = "`{$condition['field']}` IS NULL";
					} else {
						$or_wheres_group[] = "`{$condition['field']}` {$condition['operator']} '{$condition['value']}'";
					}
				}
				// Set to list.
				if ( ! empty( $or_wheres_group ) ) {
					$or_wheres[] = '(' . implode( ' AND ', $or_wheres_group ) . ')';
				}
			} elseif ( is_null( $where['value'] ) ) {
				// Process NULL condition.
				$or_wheres[] = "`{$where['field']}` IS NULL";
			} else {
				// Setup normal condition.
				$or_wheres[] = "`{$where['field']}` {$where['operator']} '{$where['value']}'";
			}
		}

		// Use it not empty.
		if ( ! empty( $or_wheres ) ) {
			$query = empty( $query ) ? implode( ' OR ', $or_wheres ) : $query . ' OR ' . implode( ' OR ', $or_wheres );
		}

		// Merge conditions to original SQL.
		if ( ! empty( $query ) ) {
			$sql = $sql . ' WHERE ' . $query;
		}

		return $sql;
	}

	/**
	 * Setup JOIN statements for tables.
	 *
	 * @param string $sql SQL query which is being built.
	 *
	 * @since 4.0
	 *
	 * @return string Query
	 */
	private function set_join( $sql ) {
		// No need to continue if empty.
		if ( empty( $this->join ) ) {
			return $sql;
		}

		foreach ( $this->join as $join ) {
			// Check if required values are set.
			if ( isset( $join['table'], $join['field1'], $join['field2'] ) ) {
				// Default operator is equals.
				$operator = isset( $join['operator'] ) ? $join['operator'] : '=';
				// Append to query.
				$sql = $sql . " JOIN `{$join['table']}` ON {$join['field1']} $operator {$join['field2']}";
			}
		}

		return $sql;
	}

	/**
	 * Set GROUP BY statement for the query.
	 *
	 * @param string $sql SQL query which is being built.
	 *
	 * @since 4.0
	 *
	 * @return string Query
	 */
	private function set_group( $sql ) {
		// Bail if not set.
		if ( empty( $this->group_by ) ) {
			return $sql;
		}

		return $sql . " GROUP BY `$this->group_by`";
	}

	/**
	 * Set ORDER BY statement for the query.
	 *
	 * @param string $sql SQL query which is being built.
	 *
	 * @since 4.0
	 *
	 * @return string Query
	 */
	private function set_order( $sql ) {
		// By default order by ID.
		if ( empty( $this->order_by ) ) {
			$sql = $sql . ' ORDER BY `id`';
		} else {
			$sql = $sql . " ORDER BY `$this->order_by`";
		}

		// Only ASC and DESC.
		if ( 'ASC' === $this->order ) {
			$sql = $sql . ' ASC';
		} else {
			$sql = $sql . ' DESC';
		}

		return $sql;
	}
}
